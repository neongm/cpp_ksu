МНОГОМЕРНЫЕ МАССИВЫ
многомерный массив представляет собой массив массивов, тоесть массив, элементами которого служат массивы. 

arr[4][3][6]; // массив, состоящий из 4х элементов, каждый из которых является массивом из 3х элементов, каждый из которых является массивом
              // из 6 элементов.

В памяти массив располгается в порядке возрастания с самого правого индекса

arr[0][0][0], arr[0][0][1], ...;

существует особенность инициализации многомерного массива:

arr[4][3][6] = {0,1,2,3,4,5,6,7}; // такая конструкция инициализирует только первые 8 элементов массива
arr[0][0][0]=0;
arr[0][0][1]=1;  // и т.д.
.......
arr[0][1][0]=6;
arr[0][1][1]=7;

для изменения последовательности при инициализации используют фигурные скобки:
{{{1}}, {{100,200}}}


МАССИВЫ УКАЗАТЕЛЕЙ
при следующем определении (int *a [6];) задается массив указателей на элементы int типа.
    a
0|  *  -->  9
1|  *  -->  1
2|  *  -->  4
3|  *  -->  12
4|  *  -->  54
5|  *  -->  4 // или любые другие Int`ы

конструкция int(*b)[6] определяет указатель на массив, элементами которого являются целые числа - не массив указателей

массивы указателей позволяют экономить память при использовании многомерных массивов
пример:

char s[][20] = {"Иванов", "Петров", "Сидоров"} // в первых [] колличество элементов = кол-ву в {}, кадлый из которых 20 символов
// 3 элемента по 20 символов

char *p[] = {"Иванов", "Петров", "Сидоров"};
// массив р указателей из 3 элементов (указатели char*, которые являются адресами расположения в памяти необходимых строк)
    р
0|  *  -->  "Иванов"
1|  *  -->  "Петров"
2|  *  -->  "Сидоров"

удобно менять элементы местами, для сортировки и прочего


массивы динамической памяти
(Выделение памяти под массив в куче)
int x,y;
1. запросить колличество точек N
2. выделить на них память

int (*a)[2][3]; // указатель а на структуру, состоящую из двух элементов, каждый из которых состоит из 3х int`ов
a = new int[5][2][3]; // Выделяется место для 5 элементов, каждый из которых имеет структуру как выше

// самый левый может быть переменной - остальные константы

int (*point)[2]; // указатель на конструкцию из 2х int`ов
point = new int[N][2]; // N шт по 2 координаты ну и прочее, годнота крч
// первый индекс - номер точки, второй - номер координаты

в некоторых случаях невозможно эти размерности задать константами, тогда выделяется место в памяти для соответствующего одномерного массива и 
организуется работа с ним как с соответствующим многомерным

int *a;
a = new int[n*m]; // одномерный массив
                  // a[i][j] equal a[i*m+j]


    ФУНКЦИИ

программа состоит из функций; обязательно должная примутствовать функция с именем main, с которой на чинается выполнение прогарммы.
Имя функции должно быть уникально в пределах приложения. 
общий вид;
<тип> <имя фунции>(<сигнатура>){
    <тело функции>
}
void - тип функции, если она не возвращает значение 
к моменту обращения к функции транслятор должен знать что такая функция существует, поэтому используют её прототип (если реализация
функции находится ниже её вызова)
Есть возможность использовать функции с переменным кол-вом агрументов
Сигнатура может содержать определяемые по умолчанию параметры
void f(int a, int b=3){}

Формат прототипа функции с пеменным числом параметров следующий:
<тип> <имя фунции>(<спецификация явных параметров>, ...){
    <тело функции>
}
спецификация явных параметров - параметры, колличество и типы которых известны на момент компиляции.
каждая такая функция должна иметь механизм определения колличества необязательных параметров. Два похода:
- добавление в конец списка параметров значения, которое будет являться признаком конца списка.
- передача в функцию реального колличества параметров

пример:
составить программу вычисления суммы заданных целых чисел с использованием колличества слагаемых

<code>    
#include <iostream>

int summa(int k, ...){  
    int *pk=&k;
    int sum = 0;
    for(;k;l--){
        sum+=*(++pk);
    }
    return sum;
}

int main(){
    std::cout<<"\nsumma(2,4,6) = "<<summa(2,4,6)<<std::endl
    std::cout<<"\nsumma(1,2,3,4,5,6) = "<<summa(1,2,3,4,5,6)<<std::endl 
}

</code>

перепишем программу используя предоределенное значение (пусть оно = 0):
<code>    
#include <iostream>

int summa(int k, ...){  
    int *pk=&k; // указатель на адрес известного параметра
    int sum = 0;
    for(;*pk;){ 
        sum+=*(pk++);
    }
    return sum;
}

int main(){
    std::cout<<"\nsumma(4,6,0) = "<<summa(4,6,0)<<std::endl
    std::cout<<"\nsumma(1,2,3,4,5,6,0) = "<<summa(1,2,3,4,5,6,0)<<std::endl 
    std::cout<<"\nsumma(1,2,0,3,4,0) = "<<summa(1,2,0,3,4,0)<<std::endl
}

</code>
